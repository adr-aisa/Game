"""
Enhanced Pathfinding Algorithm Visualizer with Hello Kitty Car
A visual tool to demonstrate pathfinding algorithms with animated character movement
"""

import pygame
import heapq
from enum import Enum
from dataclasses import dataclass
from typing import List, Tuple, Optional, Set
import random
import math

# Constants
WINDOW_WIDTH = 1100
WINDOW_HEIGHT = 770
GRID_SIZE = 40
CELL_SIZE = WINDOW_HEIGHT // GRID_SIZE

# Colors - Updated to pink, white, red theme
WHITE = (255, 255, 255)
PINK_LIGHT = (255, 192, 203)
PINK = (255, 105, 180)
PINK_DARK = (219, 39, 119)
RED = (239, 68, 68)
RED_DARK = (185, 28, 28)
BLUE = (147, 197, 253)
SKY_BLUE = (135, 206, 235)  # Sky blue for path
YELLOW = (250, 204, 21)
PURPLE = (168, 85, 247)
GRAY = (107, 114, 128)
DARK_BG = (17, 24, 39)
LIGHT_GRAY = (229, 231, 235)
BLACK = (40, 40, 40)
ORANGE = (255, 165, 0)

class CellType(Enum):
    EMPTY = 0
    WALL = 1
    START = 2
    END = 3
    VISITED = 4
    PATH = 5
    CURRENT = 6
    WAYPOINT = 7  # Static waypoints

@dataclass
class Node:
    row: int
    col: int
    type: CellType = CellType.EMPTY
    g_cost: float = float('inf')  # Distance from start
    h_cost: float = 0  # Heuristic to end
    parent: Optional['Node'] = None
    
    @property
    def f_cost(self):
        return self.g_cost + self.h_cost
    
    def __lt__(self, other):
        return self.f_cost < other.f_cost
    
    def __eq__(self, other):
        return self.row == other.row and self.col == other.col
    
    def __hash__(self):
        return hash((self.row, self.col))

class Grid:
    def __init__(self, rows: int, cols: int):
        self.rows = rows
        self.cols = cols
        self.grid: List[List[Node]] = []
        self.start: Optional[Node] = None
        self.end: Optional[Node] = None
        self.waypoints: List[Node] = []  # Static waypoints
        self.initialize()
    
    def initialize(self):
        """Initialize empty grid"""
        self.grid = []
        for row in range(self.rows):
            current_row = []
            for col in range(self.cols):
                node = Node(row, col)
                current_row.append(node)
            self.grid.append(current_row)
        
        # Set default start and end - top-left and bottom-right
        start_row, start_col = 0, 0
        end_row, end_col = self.rows - 1, self.cols - 1
        
        self.start = self.grid[start_row][start_col]
        self.start.type = CellType.START
        
        self.end = self.grid[end_row][end_col]
        self.end.type = CellType.END
        
        # Add static waypoints (middle points)
        waypoint1 = self.grid[self.rows // 3][self.cols // 2]
        waypoint1.type = CellType.WAYPOINT
        self.waypoints.append(waypoint1)
        
        waypoint2 = self.grid[2 * self.rows // 3][self.cols // 2]
        waypoint2.type = CellType.WAYPOINT
        self.waypoints.append(waypoint2)
    
    def get_node(self, row: int, col: int) -> Optional[Node]:
        """Get node at position"""
        if 0 <= row < self.rows and 0 <= col < self.cols:
            return self.grid[row][col]
        return None
    
    def get_neighbors(self, node: Node) -> List[Node]:
        """Get valid neighbors of a node"""
        neighbors = []
        directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        
        for dr, dc in directions:
            new_row, new_col = node.row + dr, node.col + dc
            neighbor = self.get_node(new_row, new_col)
            if neighbor and neighbor.type != CellType.WALL:
                neighbors.append(neighbor)
        
        return neighbors
    
    def reset_path(self):
        """Clear visited and path nodes"""
        for row in self.grid:
            for node in row:
                if node.type in [CellType.VISITED, CellType.PATH, CellType.CURRENT]:
                    node.type = CellType.EMPTY
                node.g_cost = float('inf')
                node.h_cost = 0
                node.parent = None
        # Restore waypoints
        for waypoint in self.waypoints:
            waypoint.type = CellType.WAYPOINT
    
    def clear_all(self):
        """Clear everything except start, end, and waypoints"""
        for row in self.grid:
            for node in row:
                if node.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                    node.type = CellType.EMPTY
                node.g_cost = float('inf')
                node.h_cost = 0
                node.parent = None
    
    def generate_maze(self):
        """Generate random maze"""
        self.clear_all()
        for row in self.grid:
            for node in row:
                if node.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                    if random.random() < 0.3:
                        node.type = CellType.WALL

class PathfindingAlgorithm:
    """Base class for pathfinding algorithms"""
    
    @staticmethod
    def heuristic(node1: Node, node2: Node) -> float:
        """Manhattan distance heuristic"""
        return abs(node1.row - node2.row) + abs(node1.col - node2.col)
    
    @staticmethod
    def reconstruct_path(end_node: Node) -> List[Node]:
        """Reconstruct path from end to start"""
        path = []
        current = end_node
        while current.parent:
            path.append(current)
            current = current.parent
        path.reverse()
        return path

class AStarAlgorithm(PathfindingAlgorithm):
    """A* pathfinding algorithm"""
    
    def find_path(self, grid: Grid):
        start = grid.start
        end = grid.end
        
        start.g_cost = 0
        start.h_cost = self.heuristic(start, end)
        
        open_set = [start]
        closed_set: Set[Node] = set()
        visited_order = []
        
        while open_set:
            current = heapq.heappop(open_set)
            
            if current in closed_set:
                continue
            
            closed_set.add(current)
            if current.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                current.type = CellType.VISITED
            visited_order.append(current)
            
            yield ('visiting', current)
            
            if current == end:
                path = self.reconstruct_path(end)
                yield ('complete', visited_order, path)
                return
            
            for neighbor in grid.get_neighbors(current):
                if neighbor in closed_set:
                    continue
                
                tentative_g = current.g_cost + 1
                
                if tentative_g < neighbor.g_cost:
                    neighbor.g_cost = tentative_g
                    neighbor.h_cost = self.heuristic(neighbor, end)
                    neighbor.parent = current
                    
                    if neighbor not in open_set:
                        heapq.heappush(open_set, neighbor)
        
        yield ('complete', visited_order, [])

class DijkstraAlgorithm(PathfindingAlgorithm):
    """Dijkstra's pathfinding algorithm"""
    
    def find_path(self, grid: Grid):
        start = grid.start
        end = grid.end
        
        start.g_cost = 0
        
        open_set = [start]
        closed_set: Set[Node] = set()
        visited_order = []
        
        while open_set:
            open_set.sort(key=lambda n: n.g_cost)
            current = open_set.pop(0)
            
            if current in closed_set:
                continue
            
            closed_set.add(current)
            if current.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                current.type = CellType.VISITED
            visited_order.append(current)
            
            yield ('visiting', current)
            
            if current == end:
                path = self.reconstruct_path(end)
                yield ('complete', visited_order, path)
                return
            
            for neighbor in grid.get_neighbors(current):
                if neighbor in closed_set:
                    continue
                
                tentative_g = current.g_cost + 1
                
                if tentative_g < neighbor.g_cost:
                    neighbor.g_cost = tentative_g
                    neighbor.parent = current
                    
                    if neighbor not in open_set:
                        open_set.append(neighbor)
        
        yield ('complete', visited_order, [])

class BFSAlgorithm(PathfindingAlgorithm):
    """Breadth-First Search algorithm"""
    
    def find_path(self, grid: Grid):
        start = grid.start
        end = grid.end
        
        queue = [start]
        visited: Set[Node] = {start}
        visited_order = []
        
        while queue:
            current = queue.pop(0)
            
            if current.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                current.type = CellType.VISITED
            visited_order.append(current)
            
            yield ('visiting', current)
            
            if current == end:
                path = self.reconstruct_path(end)
                yield ('complete', visited_order, path)
                return
            
            for neighbor in grid.get_neighbors(current):
                if neighbor not in visited:
                    visited.add(neighbor)
                    neighbor.parent = current
                    queue.append(neighbor)
        
        yield ('complete', visited_order, [])

class DFSAlgorithm(PathfindingAlgorithm):
    """Depth-First Search algorithm"""
    
    def find_path(self, grid: Grid):
        start = grid.start
        end = grid.end
        
        stack = [start]
        visited: Set[Node] = set()
        visited_order = []
        
        while stack:
            current = stack.pop()
            
            if current in visited:
                continue
            
            visited.add(current)
            if current.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                current.type = CellType.VISITED
            visited_order.append(current)
            
            yield ('visiting', current)
            
            if current == end:
                path = self.reconstruct_path(end)
                yield ('complete', visited_order, path)
                return
            
            for neighbor in grid.get_neighbors(current):
                if neighbor not in visited:
                    neighbor.parent = current
                    stack.append(neighbor)
        
        yield ('complete', visited_order, [])

class GreedyBestFirstAlgorithm(PathfindingAlgorithm):
    """Greedy Best-First Search algorithm - uses only heuristic"""
    
    def find_path(self, grid: Grid):
        start = grid.start
        end = grid.end
        
        start.h_cost = self.heuristic(start, end)
        
        open_set = [start]
        closed_set: Set[Node] = set()
        visited_order = []
        
        while open_set:
            open_set.sort(key=lambda n: n.h_cost)
            current = open_set.pop(0)
            
            if current in closed_set:
                continue
            
            closed_set.add(current)
            if current.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                current.type = CellType.VISITED
            visited_order.append(current)
            
            yield ('visiting', current)
            
            if current == end:
                path = self.reconstruct_path(end)
                yield ('complete', visited_order, path)
                return
            
            for neighbor in grid.get_neighbors(current):
                if neighbor in closed_set:
                    continue
                
                neighbor.h_cost = self.heuristic(neighbor, end)
                neighbor.parent = current
                
                if neighbor not in open_set:
                    open_set.append(neighbor)
        
        yield ('complete', visited_order, [])

class BidirectionalSearchAlgorithm(PathfindingAlgorithm):
    """Bidirectional Search - searches from both start and end"""
    
    def find_path(self, grid: Grid):
        start = grid.start
        end = grid.end
        
        # Forward search from start
        forward_queue = [start]
        forward_visited = {start}
        forward_parent = {start: None}
        
        # Backward search from end
        backward_queue = [end]
        backward_visited = {end}
        backward_parent = {end: None}
        
        visited_order = []
        
        while forward_queue and backward_queue:
            # Forward step
            if forward_queue:
                current = forward_queue.pop(0)
                
                if current.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                    current.type = CellType.VISITED
                visited_order.append(current)
                
                yield ('visiting', current)
                
                # Check if paths meet
                if current in backward_visited:
                    path = self._reconstruct_bidirectional_path(
                        current, forward_parent, backward_parent
                    )
                    yield ('complete', visited_order, path)
                    return
                
                for neighbor in grid.get_neighbors(current):
                    if neighbor not in forward_visited:
                        forward_visited.add(neighbor)
                        forward_parent[neighbor] = current
                        forward_queue.append(neighbor)
            
            # Backward step
            if backward_queue:
                current = backward_queue.pop(0)
                
                if current.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                    current.type = CellType.VISITED
                visited_order.append(current)
                
                yield ('visiting', current)
                
                # Check if paths meet
                if current in forward_visited:
                    path = self._reconstruct_bidirectional_path(
                        current, forward_parent, backward_parent
                    )
                    yield ('complete', visited_order, path)
                    return
                
                for neighbor in grid.get_neighbors(current):
                    if neighbor not in backward_visited:
                        backward_visited.add(neighbor)
                        backward_parent[neighbor] = current
                        backward_queue.append(neighbor)
        
        yield ('complete', visited_order, [])
    
    def _reconstruct_bidirectional_path(self, meeting_point, forward_parent, backward_parent):
        """Reconstruct path from bidirectional search"""
        path = []
        
        # Forward path
        current = meeting_point
        forward_path = []
        while current is not None:
            forward_path.append(current)
            current = forward_parent.get(current)
        forward_path.reverse()
        
        # Backward path
        current = backward_parent.get(meeting_point)
        backward_path = []
        while current is not None:
            backward_path.append(current)
            current = backward_parent.get(current)
        
        path = forward_path + backward_path
        return path

class GirlyBowTie:
    """Pink girly bow tie that moves along the path"""
    
    def __init__(self, cell_size: int):
        self.cell_size = cell_size
        self.current_pos = None
        self.target_pos = None
        self.path = []
        self.path_index = 0
        self.animation_progress = 0
        self.animation_speed = 0.1
        self.is_animating = False
    
    def start_animation(self, path: List[Node], start_node: Node):
        """Start bow tie animation along path"""
        if not path:
            return
        
        self.path = [start_node] + path
        self.path_index = 0
        self.animation_progress = 0
        self.is_animating = True
        
        if self.path:
            node = self.path[0]
            self.current_pos = (node.col * self.cell_size, node.row * self.cell_size)
            if len(self.path) > 1:
                next_node = self.path[1]
                self.target_pos = (next_node.col * self.cell_size, next_node.row * self.cell_size)
    
    def update(self):
        """Update bow tie position"""
        if not self.is_animating or not self.path:
            return
        
        self.animation_progress += self.animation_speed
        
        if self.animation_progress >= 1.0:
            self.animation_progress = 0
            self.path_index += 1
            
            if self.path_index >= len(self.path):
                self.is_animating = False
                return
            
            node = self.path[self.path_index]
            self.current_pos = (node.col * self.cell_size, node.row * self.cell_size)
            
            if self.path_index + 1 < len(self.path):
                next_node = self.path[self.path_index + 1]
                self.target_pos = (next_node.col * self.cell_size, next_node.row * self.cell_size)
            else:
                self.is_animating = False
    
    def get_position(self):
        """Get interpolated position"""
        if not self.current_pos or not self.target_pos:
            return self.current_pos
        
        x = self.current_pos[0] + (self.target_pos[0] - self.current_pos[0]) * self.animation_progress
        y = self.current_pos[1] + (self.target_pos[1] - self.current_pos[1]) * self.animation_progress
        
        return (x, y)
    
    def draw(self, surface: pygame.Surface):
        """Draw pink girly bow tie"""
        if not self.is_animating or not self.current_pos:
            return
        
        pos = self.get_position()
        center_x = pos[0] + self.cell_size // 2
        center_y = pos[1] + self.cell_size // 2
        
        bow_size = self.cell_size // 2
        
        # Left bow loop (ellipse)
        left_bow = pygame.Rect(
            center_x - bow_size * 1.3,
            center_y - bow_size * 0.6,
            bow_size * 1.2,
            bow_size * 1.2
        )
        pygame.draw.ellipse(surface, PINK, left_bow)
        pygame.draw.ellipse(surface, PINK_DARK, left_bow, 3)
        
        # Right bow loop (ellipse)
        right_bow = pygame.Rect(
            center_x + bow_size * 0.1,
            center_y - bow_size * 0.6,
            bow_size * 1.2,
            bow_size * 1.2
        )
        pygame.draw.ellipse(surface, PINK, right_bow)
        pygame.draw.ellipse(surface, PINK_DARK, right_bow, 3)
        
        # Center knot (circle)
        pygame.draw.circle(surface, PINK, (int(center_x), int(center_y)), int(bow_size * 0.3))
        pygame.draw.circle(surface, PINK_DARK, (int(center_x), int(center_y)), int(bow_size * 0.3), 2)
        
        # Left ribbon (hanging down)
        left_ribbon = [
            (center_x - bow_size * 0.2, center_y + bow_size * 0.2),
            (center_x - bow_size * 0.5, center_y + bow_size * 1.3),
            (center_x - bow_size * 0.4, center_y + bow_size * 1.4),
            (center_x, center_y + bow_size * 0.4)
        ]
        pygame.draw.polygon(surface, PINK, left_ribbon)
        pygame.draw.polygon(surface, PINK_DARK, left_ribbon, 2)
        
        # Right ribbon (hanging down)
        right_ribbon = [
            (center_x + bow_size * 0.2, center_y + bow_size * 0.2),
            (center_x + bow_size * 0.5, center_y + bow_size * 1.3),
            (center_x + bow_size * 0.4, center_y + bow_size * 1.4),
            (center_x, center_y + bow_size * 0.4)
        ]
        pygame.draw.polygon(surface, PINK, right_ribbon)
        pygame.draw.polygon(surface, PINK_DARK, right_ribbon, 2)

class Visualizer:
    """Main visualizer class"""
    
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        pygame.display.set_caption("ðŸŽ€ Hello Kitty Pathfinding Visualizer")
        self.clock = pygame.time.Clock()
        
        self.grid = Grid(GRID_SIZE, GRID_SIZE)
        self.algorithms = {
            'A*': AStarAlgorithm(),
            'Dijkstra': DijkstraAlgorithm(),
            'BFS': BFSAlgorithm(),
            'DFS': DFSAlgorithm(),
            'Greedy': GreedyBestFirstAlgorithm(),
            'Bidirectional': BidirectionalSearchAlgorithm()
        }
        self.current_algorithm = 'A*'
        self.algorithm_generator = None
        
        self.is_running = False
        self.is_drawing = False
        self.speed = 50  # FPS
        
        self.stats = {
            'visited': 0,
            'path_length': 0,
            'algorithm': self.current_algorithm
        }
        
        # Pink girly bow tie
        self.bowtie = GirlyBowTie(CELL_SIZE)
        
        # UI
        self.font = pygame.font.Font(None, 32)
        self.small_font = pygame.font.Font(None, 24)
    
    def get_cell_color(self, cell_type: CellType) -> Tuple[int, int, int]:
        """Get color for cell type - pink, white, red theme"""
        color_map = {
            CellType.EMPTY: WHITE,
            CellType.WALL: BLACK,
            CellType.START: PINK,
            CellType.END: RED,
            CellType.VISITED: PINK_LIGHT,
            CellType.PATH: SKY_BLUE,
            CellType.CURRENT: PURPLE,
            CellType.WAYPOINT: ORANGE
        }
        return color_map.get(cell_type, WHITE)
    
    def draw_grid(self):
        """Draw the grid"""
        grid_width = self.grid.cols * CELL_SIZE
        grid_height = self.grid.rows * CELL_SIZE
        
        for row in range(self.grid.rows):
            for col in range(self.grid.cols):
                node = self.grid.grid[row][col]
                color = self.get_cell_color(node.type)
                
                x = col * CELL_SIZE
                y = row * CELL_SIZE
                
                pygame.draw.rect(self.screen, color, (x, y, CELL_SIZE, CELL_SIZE))
                
                # Checkerboard pattern for empty cells
                if node.type == CellType.EMPTY:
                    if (row + col) % 2 == 0:
                        pygame.draw.rect(self.screen, PINK_LIGHT, (x, y, CELL_SIZE, CELL_SIZE))
                
                pygame.draw.rect(self.screen, LIGHT_GRAY, (x, y, CELL_SIZE, CELL_SIZE), 1)
    
    def draw_ui(self):
        """Draw UI elements"""
        # Background for UI
        ui_x = self.grid.cols * CELL_SIZE
        pygame.draw.rect(self.screen, DARK_BG, (ui_x, 0, WINDOW_WIDTH - ui_x, WINDOW_HEIGHT))
        
        y_offset = 20
        
        # Title
        title = self.font.render("Hello Kitty", True, PINK)
        self.screen.blit(title, (ui_x + 20, y_offset))
        y_offset += 35
        subtitle = self.small_font.render("Pathfinding", True, WHITE)
        self.screen.blit(subtitle, (ui_x + 20, y_offset))
        y_offset += 40
        
        # Algorithm selection
        algo_text = self.small_font.render("Algorithm:", True, WHITE)
        self.screen.blit(algo_text, (ui_x + 20, y_offset))
        y_offset += 30
        
        for i, algo_name in enumerate(self.algorithms.keys()):
            color = PINK if algo_name == self.current_algorithm else GRAY
            algo_btn = self.small_font.render(f"[{algo_name}]", True, color)
            self.screen.blit(algo_btn, (ui_x + 20, y_offset + i * 25))
        
        y_offset += 180
        
        # Stats
        stats_title = self.small_font.render("Statistics:", True, WHITE)
        self.screen.blit(stats_title, (ui_x + 20, y_offset))
        y_offset += 30
        
        visited_text = self.small_font.render(f"Visited: {self.stats['visited']}", True, PINK_LIGHT)
        self.screen.blit(visited_text, (ui_x + 20, y_offset))
        y_offset += 30
        
        path_text = self.small_font.render(f"Path: {self.stats['path_length']}", True, SKY_BLUE)
        self.screen.blit(path_text, (ui_x + 20, y_offset))
        y_offset += 50
        
        # Instructions
        instructions = [
            "Controls:",
            "SPACE - Start",
            "ESC - Stop & Restart",
            "C - Clear Path",
            "M - Generate Maze",
            "1-6 - Algorithm",
            "",
            "Left Click - Walls",
            "Shift+Click - Start",
            "Ctrl+Click - End"
        ]
        
        # Show running status
        if self.is_running:
            status_text = self.small_font.render("STATUS: Running...", True, (0, 255, 0))
            self.screen.blit(status_text, (ui_x + 20, y_offset))
            y_offset += 30
        elif self.bowtie.is_animating:
            status_text = self.small_font.render("STATUS: Animating...", True, PINK)
            self.screen.blit(status_text, (ui_x + 20, y_offset))
            y_offset += 30
        
        for instruction in instructions:
            text = self.small_font.render(instruction, True, WHITE)
            self.screen.blit(text, (ui_x + 20, y_offset))
            y_offset += 25
    
    def handle_mouse_click(self, pos: Tuple[int, int], button: int, shift_pressed: bool = False, ctrl_pressed: bool = False):
        """Handle mouse click on grid"""
        if self.is_running:
            return
            
        x, y = pos
        col = x // CELL_SIZE
        row = y // CELL_SIZE
        
        if col >= self.grid.cols or row >= self.grid.rows:
            return
        
        node = self.grid.get_node(row, col)
        if not node:
            return
        
        # Shift + Left click to place start point
        if button == 1 and shift_pressed:
            if node.type not in [CellType.END, CellType.WAYPOINT]:
                if self.grid.start:
                    self.grid.start.type = CellType.EMPTY
                node.type = CellType.START
                self.grid.start = node
        
        # Ctrl + Left click to place end point
        elif button == 1 and ctrl_pressed:
            if node.type not in [CellType.START, CellType.WAYPOINT]:
                if self.grid.end:
                    self.grid.end.type = CellType.EMPTY
                node.type = CellType.END
                self.grid.end = node
        
        # Left click to draw walls
        elif button == 1:
            if node.type not in [CellType.START, CellType.END, CellType.WAYPOINT]:
                node.type = CellType.WALL if node.type != CellType.WALL else CellType.EMPTY
    
    def stop_algorithm(self):
        """Stop and restart"""
        self.is_running = False
        self.algorithm_generator = None
        self.bowtie.is_animating = False
        self.grid.clear_all()
        self.grid.initialize()
        self.stats['visited'] = 0
        self.stats['path_length'] = 0
        self.current_algorithm = 'A*'
    
    def start_algorithm(self):
        """Start the selected algorithm - goes through waypoints in order"""
        if self.is_running or self.bowtie.is_animating:
            return
        
        self.grid.reset_path()
        self.stats['visited'] = 0
        self.stats['path_length'] = 0
        self.stats['algorithm'] = self.current_algorithm
        
        # Build complete path through all waypoints
        all_waypoints = [self.grid.start] + self.grid.waypoints + [self.grid.end]
        complete_path = []
        
        # Find path between each pair of consecutive waypoints
        for i in range(len(all_waypoints) - 1):
            start_point = all_waypoints[i]
            end_point = all_waypoints[i + 1]
            
            # Temporarily set start and end for this segment
            self.grid.start = start_point
            self.grid.end = end_point
            
            # Reset costs for pathfinding
            for row in self.grid.grid:
                for node in row:
                    node.g_cost = float('inf')
                    node.h_cost = 0
                    node.parent = None
            
            # Run algorithm for this segment
            algorithm = self.algorithms[self.current_algorithm]
            gen = algorithm.find_path(self.grid)
            
            # Get the path for this segment
            segment_path = []
            for result in gen:
                if result[0] == 'complete':
                    segment_path = result[2]
                    break
            
            # Add to complete path (avoid duplicating waypoint nodes between segments)
            if i == 0:
                # First segment: add start point
                complete_path.append(start_point)
            
            if segment_path:
                complete_path.extend(segment_path)
            else:
                # If no path found, add the endpoint anyway
                complete_path.append(end_point)
        
        # Restore original start and end
        self.grid.start = all_waypoints[0]
        self.grid.end = all_waypoints[-1]
        
        # Mark the complete path - DON'T skip start, end, or waypoints!
        for node in complete_path:
            if node.type == CellType.EMPTY or node.type == CellType.VISITED:
                node.type = CellType.PATH
        
        # Make sure all waypoints, start, and end are visible
        for waypoint in all_waypoints:
            if waypoint == self.grid.start:
                waypoint.type = CellType.START
            elif waypoint == self.grid.end:
                waypoint.type = CellType.END
            elif waypoint in self.grid.waypoints:
                waypoint.type = CellType.WAYPOINT
        
        # Update stats
        self.stats['path_length'] = len(complete_path)
        
        # Start cat animation through all waypoints
        if complete_path:
            self.bowtie.start_animation(complete_path, all_waypoints[0])
    
    def step_algorithm(self):
        """No longer needed - path is calculated all at once"""
        pass
    
    def run(self):
        """Main loop"""
        running = True
        
        while running:
            self.clock.tick(self.speed)
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    self.is_drawing = True
                    keys = pygame.key.get_mods()
                    shift_pressed = keys & pygame.KMOD_SHIFT
                    ctrl_pressed = keys & pygame.KMOD_CTRL
                    self.handle_mouse_click(event.pos, event.button, shift_pressed, ctrl_pressed)
                
                elif event.type == pygame.MOUSEBUTTONUP:
                    self.is_drawing = False
                
                elif event.type == pygame.MOUSEMOTION:
                    if self.is_drawing:
                        keys = pygame.key.get_mods()
                        shift_pressed = keys & pygame.KMOD_SHIFT
                        ctrl_pressed = keys & pygame.KMOD_CTRL
                        self.handle_mouse_click(event.pos, 1, shift_pressed, ctrl_pressed)
                
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_SPACE:
                        self.start_algorithm()
                    elif event.key == pygame.K_ESCAPE:
                        self.stop_algorithm()
                    elif event.key == pygame.K_c:
                        if not self.is_running:
                            self.grid.reset_path()
                            self.stats['visited'] = 0
                            self.stats['path_length'] = 0
                            self.bowtie.is_animating = False
                    elif event.key == pygame.K_m:
                        if not self.is_running:
                            self.grid.generate_maze()
                    elif event.key == pygame.K_1:
                        self.current_algorithm = 'A*'
                    elif event.key == pygame.K_2:
                        self.current_algorithm = 'Dijkstra'
                    elif event.key == pygame.K_3:
                        self.current_algorithm = 'BFS'
                    elif event.key == pygame.K_4:
                        self.current_algorithm = 'DFS'
                    elif event.key == pygame.K_5:
                        self.current_algorithm = 'Greedy'
                    elif event.key == pygame.K_6:
                        self.current_algorithm = 'Bidirectional'
            
            # Cat animation update only
            self.bowtie.update()
            
            self.screen.fill(DARK_BG)
            self.draw_grid()
            self.bowtie.draw(self.screen)
            self.draw_ui()
            pygame.display.flip()
        
        pygame.quit()

if __name__ == "__main__":
    visualizer = Visualizer()
    visualizer.run()